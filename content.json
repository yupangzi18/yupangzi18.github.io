{"pages":[],"posts":[{"title":"CSAPP - Integer and Float","text":"Integer Representation Data types char, short, int, long, float, double, pointer Word size equals length of pointer datatype Bit-level operations Signed / unsigned conversion Byte ordering Big Endian: Sun, PPC Mac, Internet Little Endian: x86, ARM Float: IEEE 754 Numeric form: $(-1)^s \\times M \\times 2^E$ Encoding s: sign bit exp: $E$ frac: $M$ Three kinds of values Denormalized: $exp$ = 0 Normalized: 0 &lt; $exp$ &lt; 11..11 Special: exp = 11…11 (e.g. inf &amp; NaN) Roundings to even","link":"/csapp-integer-and-float/index.html"},{"title":"CSAPP - Machine Level Programming","text":"x86-64 History 8086 -&gt; 386 -&gt; Pentium 4E -&gt; Core 2 -&gt; Core i7 IA32 -&gt; x86-64 CISC architecture Case study: Core-i7 6700K Skylake Shared L3 cache (LLC) Hyper-Threading: Shared caches, buses &amp; ALUs Registers Can reference low-order 4 bytes (backwards compatibility) %rsp is stack top, others are general-purpose %rip is instruction pointer (not listed) A register for implicitly-set condition codes Machine Level ProgrammingAddressing modes Normal: (R) -&gt; Mem[Reg[R]] Displacement: D(R) -&gt; Mem[Reg[R] + D] Complete: D(Rb,Ri,S) -&gt; Mem[Reg[Rb] + S*Reg[Ri] + D] (Rb,Ri) -&gt; Mem[Reg[Rb] + Reg[Ri]] D(Rb,Ri) -&gt; Mem[Reg[Rb] + Reg[Ri] + D] (Rb,Ri,S) -&gt; Mem[Reg[Rb] + S*Reg[Ri]] Some instructions movq Src, Dst Cannot do memory-memory transfer with a single instruction Intel docs use mov Dst, Src leaq Src, Dst Src is address mode expression, set Dst to address denoted by expression Similar to p = &amp;x[i] Used for arithmetics for form like x + k * y Does not change condition codes addq/subq Src, Dst imulq Src, Dst salq/sarq/shrq Src, Dst xorq/andq/orq Src, Dst pushq src popq dest incr dest Compiler, Assembler, Linker &amp; Loader Compiler Translates C files (.c) into assembly files (.s) Assembler Translates assembly files (.s) into object files (.o) Missing linkage between compilation units Linker Resolve references between object files Combine with static libraries (malloc, printf, etc) Dynamic linked libraries Linking occurs at runtime Does not take too much disk space Controls Jumping jmp, je, jne, js … However, branches are very disruptive to instruction flow through pipelines Conditional moves: cmovle Do not require control transfer Use -fno-if-conversion flag to supress implicit conversion Switch statements Jump table structure Make use of “fall through” Procedures Passing control Procedure call: call label Push return address into stack Jump to label Procedure return: ret Pop return address from stack Jump to this address Return address: Address of next instruction after the call statement Passing data First 6 arguments: %rdi, %rsi, %rdx, %rcx, %r8, %r9 Other arguments passed using stack Return value: %rax IA-32 pass all arguments in stack Concept of stack frames: Marked by %rbp (optional) and %rsp No additional mechanism for recursion is needed Register saving conditions Caller saved %rdi, %rsi, %rdx, %rcx, %r8, %r9, %rax, %r10, %r11 Callee saved %rbx, %r12, %r13, %r14, %rbp %rsp is also a special form of callee-saved Memory management ABI: Application Binary Interface Data Arrays 1D arrays Nested 2D arrays: int A[R][C] Multi-level 2D arrays: Structs Represented as block of memory Fields are ordered according to declaration Alignment: Within struct: Each element has alignment requirement K, where K is the size of this element Overall: Each struct has alignment requirement K, where K is the largest alignment of any element in struct To save space, put large data types first Float operations Arguments passed in %xmm0, %xmm1, … Result returned in %xmm0 Different mov instructions are used to move floats Address space Currently using 47-bit addresses (highest address of 0x7fffffffffff) Maximum stack size of 8MB on most machines Vulnerablities Buffer overflow Triggered by functions manipulating strings of arbitrary length gets, strcpy, strcat, scanf, fscanf, sscanf Return-oriented programming (ROT) Make use of “gadgets” in text segment Trigger with ret instruction Protection Use routines limiting string lengths (user-level) Randomized stack offsets Nonexecutable code segments Stack canaries","link":"/csapp-machine-level-programming/index.html"}],"tags":[{"name":"CSAPP","slug":"CSAPP","link":"/tags/CSAPP/"},{"name":"Integer","slug":"Integer","link":"/tags/Integer/"},{"name":"Float","slug":"Float","link":"/tags/Float/"}],"categories":[{"name":"CSAPP","slug":"CSAPP","link":"/categories/CSAPP/"}]}