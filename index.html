<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yupangzi18.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Yu Luo">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yupangzi18.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CMU-15-213-Intro-to-Computer-Systems" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/cmu-15-213-intro-to-computer-systems/index.html" class="article-date">
  <time datetime="2020-12-10T12:14:35.000Z" itemprop="datePublished">2020-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/cmu-15-213-intro-to-computer-systems/index.html">CMU-15-213-Intro-to-Computer-Systems</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Notes and labs for the course 15-213 Introduction to Computer Systems at CMU referenced from JonnyKong.</p>
<h1 id="Integer-representation"><a href="#Integer-representation" class="headerlink" title="Integer representation"></a>Integer representation</h1><ul>
<li>Data types<ul>
<li>char, short, int, long, float, double, pointer</li>
<li>Word size equals length of pointer datatype</li>
</ul>
</li>
<li>Bit-level operations</li>
<li>Signed / unsigned conversion</li>
<li>Byte ordering<ul>
<li>Big Endian: Sun, PPC Mac, Internet</li>
<li>Little Endian: x86, ARM  <img src="/images/endian.png" width="50%">


</li>
</ul>
</li>
</ul>
<h1 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h1><ul>
<li>Numeric form: (-1)^s*M*(2^E)</li>
<li>Encoding<ul>
<li>s: sign bit</li>
<li>exp: E</li>
<li>frac: M  <img src="/images/ieee754.png" width="50%"></li>
</ul>
</li>
<li>Three kinds of values<ul>
<li>Denormalized: exp = 0</li>
<li>Normalized: 0 &lt; exp &lt; 11..11</li>
<li>Special: exp = 11…11 (e.g. inf &amp; NaN)  <img src="/images/ieee754range.png" width="60%"></li>
</ul>
</li>
<li>Roundings</li>
</ul>
<h1 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h1><ul>
<li>History<ul>
<li>8086 -&gt; 386 -&gt; Pentium 4E -&gt; Core 2 -&gt; Core i7</li>
<li>IA32 -&gt; x86-64</li>
<li>CISC architecture</li>
<li>Case study: Core-i7 6700K Skylake<ul>
<li>Shared L3 cache (LLC)</li>
<li>Hyper-Threading: Shared caches, buses &amp; ALUs<img src="/images/corei7.png" width="70%"></li>
</ul>
</li>
</ul>
</li>
<li>Registers  <ul>
<li>Can reference low-order 4 bytes (backwards compatibility)</li>
<li><code>%rsp</code> is stack top, others are general-purpose  <img src="/images/registers.png" width="50%">  </li>
<li><code>%rip</code> is instruction pointer (not listed)  </li>
<li>A register for implicitly-set condition codes</li>
</ul>
</li>
</ul>
<h1 id="Machine-level-Programming"><a href="#Machine-level-Programming" class="headerlink" title="Machine-level Programming"></a>Machine-level Programming</h1><ul>
<li>Addressing modes<ul>
<li>Normal: <code>(R)</code> -&gt; <code>Mem[Reg[R]]</code></li>
<li>Displacement: <code>D(R)</code> -&gt; <code>Mem[Reg[R] + D]</code></li>
<li>Complete: <code>D(Rb,Ri,S)</code> -&gt; <code>Mem[Reg[Rb] + S*Reg[Ri] + D]</code><ul>
<li><code>(Rb,Ri)</code> -&gt; <code>Mem[Reg[Rb] + Reg[Ri]]</code></li>
<li><code>D(Rb,Ri)</code> -&gt; <code>Mem[Reg[Rb] + Reg[Ri] + D]</code></li>
<li><code>(Rb,Ri,S)</code> -&gt; <code>Mem[Reg[Rb] + S*Reg[Ri]]</code></li>
</ul>
</li>
</ul>
</li>
<li>Some instructions<ul>
<li><code>movq Src, Dst</code><ul>
<li>Cannot do memory-memory transfer with a single instruction</li>
<li>Intel docs use <code>mov Dst, Src</code></li>
</ul>
</li>
<li><code>leaq Src, Dst</code><ul>
<li>Src is address mode expression, set Dst to address denoted by expression</li>
<li>Similar to <code>p = &amp;x[i]</code></li>
<li>Used for arithmetics for form like <code>x + k * y</code></li>
<li>Does not change condition codes</li>
</ul>
</li>
<li><code>addq/subq Src, Dst</code></li>
<li><code>imulq Src, Dst</code></li>
<li><code>salq/sarq/shrq Src, Dst</code></li>
<li><code>xorq/andq/orq Src, Dst</code></li>
<li><code>pushq src</code></li>
<li><code>popq dest</code></li>
<li><code>incr dest</code></li>
</ul>
</li>
<li>Compiler, Assembler, Linker &amp; Loader  <ol>
<li>Compiler<ul>
<li>Translates C files (.c) into assembly files (.s)</li>
</ul>
</li>
<li>Assembler<ul>
<li>Translates assembly files (.s) into object files (.o)</li>
<li>Missing linkage between compilation units</li>
</ul>
</li>
<li>Linker<ul>
<li>Resolve references between object files</li>
<li>Combine with static libraries (malloc, printf, etc)</li>
</ul>
</li>
<li>Dynamic linked libraries<ul>
<li>Linking occurs at runtime</li>
<li>Does not take too much disk space  <img src="/images/compilation.png" width="50%">  </li>
</ul>
</li>
</ol>
</li>
<li>Controls<ul>
<li>Jumping<ul>
<li><code>jmp</code>, <code>je</code>, <code>jne</code>, <code>js</code> …</li>
<li>However, branches are very disruptive to instruction flow through pipelines</li>
</ul>
</li>
<li>Conditional moves: <code>cmovle</code><ul>
<li>Do not require control transfer</li>
<li>Use <code>-fno-if-conversion</code> flag to supress implicit conversion</li>
</ul>
</li>
<li>Switch statements<ul>
<li>Jump table structure  <img src="/images/jump_table.png" width="80%">  </li>
<li>Make use of “fall through”</li>
</ul>
</li>
</ul>
</li>
<li>Procedures<ul>
<li>Passing control<ul>
<li>Procedure call: <code>call label</code><ul>
<li>Push return address into stack</li>
<li>Jump to label</li>
</ul>
</li>
<li>Procedure return: <code>ret</code><ul>
<li>Pop return address from stack</li>
<li>Jump to this address</li>
</ul>
</li>
<li>Return address: Address of next instruction after the call statement</li>
</ul>
</li>
<li>Passing data<ul>
<li>First 6 arguments: <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code></li>
<li>Other arguments passed using stack</li>
<li>Return value: <code>%rax</code></li>
<li>IA-32 pass all arguments in stack</li>
<li>Concept of stack frames:<ul>
<li>Marked by <code>%rbp</code> (optional) and <code>%rsp</code></li>
<li>No additional mechanism for recursion is needed  <img src="/images/stack_frame.png" width="60%"></li>
</ul>
</li>
<li>Register saving conditions<ul>
<li>Caller saved<ul>
<li><code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>, <code>%rax</code>, <code>%r10</code>, <code>%r11</code></li>
</ul>
</li>
<li>Callee saved<ul>
<li><code>%rbx</code>, <code>%r12</code>, <code>%r13</code>, <code>%r14</code>, <code>%rbp</code></li>
<li><code>%rsp</code> is also a special form of callee-saved</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Memory management</li>
<li>ABI: Application Binary Interface</li>
</ul>
</li>
<li>Data<ol>
<li>Arrays  <ul>
<li>1D arrays  <img src="/images/arrays.png" width="60%">  </li>
<li>Nested 2D arrays: <code>int A[R][C]</code><img src="/images/array_nested.png" width="80%">  </li>
<li>Multi-level 2D arrays:  <img src="/images/array_multilevel.png" width="80%">  </li>
</ul>
</li>
<li>Structs<ul>
<li>Represented as block of memory<img src="/images/struct.png" width="80%">  </li>
<li>Fields are ordered according to declaration</li>
<li>Alignment:  <ul>
<li>Within struct: Each element has alignment requirement K, where K is the size of this element<img src="/images/alignment.png" width="80%">  </li>
<li>Overall: Each struct has alignment requirement K, where K is the largest alignment of any element in struct<img src="/images/alignment_overall.png" width="80%">  </li>
<li>To save space, put large data types first</li>
</ul>
</li>
</ul>
</li>
<li>Float operations<ul>
<li>Arguments passed in <code>%xmm0</code>, <code>%xmm1</code>, …</li>
<li>Result returned in <code>%xmm0</code></li>
<li>Different mov instructions are used to move floats</li>
</ul>
</li>
</ol>
</li>
<li>Address space<ul>
<li>Currently using 47-bit addresses (highest address of 0x7fffffffffff)</li>
<li>Maximum stack size of 8MB on most machines  <img src="/images/memory.png" width="60%">  </li>
</ul>
</li>
<li>Vulnerablities<ol>
<li>Buffer overflow<ul>
<li>Triggered by functions manipulating strings of arbitrary length</li>
<li><code>gets</code>, <code>strcpy</code>, <code>strcat</code>, <code>scanf</code>, <code>fscanf</code>, <code>sscanf</code></li>
</ul>
</li>
<li>Return-oriented programming (ROT)<ul>
<li>Make use of “gadgets” in text segment  </li>
<li>Trigger with <code>ret</code> instruction  <img src="/images/rop.png" width="60%">  </li>
</ul>
</li>
</ol>
</li>
<li>Protection<ol>
<li>Use routines limiting string lengths (user-level)</li>
<li>Randomized stack offsets</li>
<li>Nonexecutable code segments</li>
<li>Stack canaries</li>
</ol>
</li>
</ul>
<h1 id="Code-optimization"><a href="#Code-optimization" class="headerlink" title="Code optimization"></a>Code optimization</h1><ul>
<li><p>Optimization by programmer</p>
<ol>
<li>Code motion: Reduce frequency of computations performed   <img src="/images/code_motion.png" width="80%">   
GCC will do this with -O1  </li>
<li>Reduction in strength: Reduce costly operation with simpler one  <img src="/images/reduction_in_strength.png" width="80%">  
Here, int mul requires 3 clock cycles, int add requires 1 clock cycle </li>
<li>Share common subexpressions  <img src="/images/share_common_subexpressions.png" width="80%">  
</li>
</ol>
</li>
<li><p>Optimization blockers</p>
<ol>
<li>Procedures: Seen as a “black box”<ul>
<li>Procedures may have side effects</li>
<li>May not return same result with same argument</li>
<li>Fix: Use inline functions (GCC with -O1 within single file)</li>
</ul>
</li>
<li>Memory aliasing: Two memory references specify single location<ul>
<li>The following code does memory load and store every time, because compiler assume possibility of memory aliasing:  <img src="/images/memory_aliasing.png" width=80%>  </li>
<li>Load and store take multiple clock cycles</li>
<li>Easily caused by direct access to storage structures</li>
<li>Fix: Define local variable to tell compiler not to check for aliasing<img src="/images/aliasing_fix.png" width=60%>  </li>
<li>Get in habit of introducing local variables accumulating within loops</li>
</ul>
</li>
</ol>
</li>
<li><p>Optimization (by programmer) limitations</p>
<ol>
<li>Most performed within procedures. Newer versions of GCC do interprocedual optimization, but not between codes in different files</li>
<li>Based on static information</li>
<li>Conservative: Must not change program behavior</li>
</ol>
</li>
<li><p>Instruction-level parallelism</p>
<ul>
<li><p>Superscalar processor: Issue and execute multuple instructions per cycle, and instructions are scheduled dynamically</p>
</li>
<li><p>Some instruction have &gt;1 clock cycle latency, but can be pipelined:  </p>
<img src="/images/pipeline.png" width=70%>  
</li>
<li><p>Unrolling</p>
<ul>
<li><p>Break sequential dependency to break through latency bound (to approach throughput bound)  </p>
<img src="/images/unrolling.png" width=30%>  

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; limit; ++i)</span><br><span class="line">    x &#x3D; x + d[i];</span><br></pre></td></tr></table></figure>

<p>can be optimized to:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; limit; i +&#x3D; 2)</span><br><span class="line">    x &#x3D; (x + d[i]) + d[i + 1];</span><br></pre></td></tr></table></figure>

<p>but to break sequential dependency:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; limit; i +&#x3D; 2)</span><br><span class="line">    x &#x3D; x + (d[i] + d[i + 1]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>adding separate accumulators</p>
</li>
</ul>
</li>
<li><p>Branch prediction</p>
<ul>
<li>Backward branches are often loops, predict taken</li>
<li>Forward branches are often if, predict not taken</li>
<li>Average better than 95% accuracy</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1><ul>
<li>Storage technologies<ol>
<li>RAMs<ul>
<li>Volatile: SRAM &amp; DRAM (caches &amp; main memories)</li>
<li>Nonvolatile: ROM, PROM, EPROM, EEPROM (firmware, ssd &amp; disk caches)</li>
</ul>
</li>
<li>Rotating disks</li>
<li>SSDs<ul>
<li>Page can be written only after its block has been erased</li>
</ul>
</li>
</ol>
</li>
<li>Locality<ul>
<li>Temporal locality</li>
<li>Spatial locality</li>
</ul>
</li>
<li>Hierarchy  <img src="/images/hierarchy.png" width=70%>  </li>
<li>Caches<ul>
<li>Each level in hierarchy serves as cache for the level below</li>
<li>Types of cache misses<ol>
<li>Cold miss: “Warm up” cache</li>
<li>Capacity miss: Working set larger than cache size</li>
<li>Conflict miss: Limited by positioning restrictions imposed by hardware</li>
</ol>
</li>
<li>Examples of cache  <img src="/images/cache_examples.png" width=70%>  </li>
</ul>
</li>
<li>Cache memories<ul>
<li>Concept of locality  <img src="/images/locality.png" width=60%>  </li>
<li>General organization  <img src="/images/address.png" width=20%>
<img src="/images/organization.png" width=50%>  
1. Direct mapped cache has (E / associativity = 1)  
   <img src="/images/direct_mapped_cache.png" width=50%>  
2. E-way set associative cache (Here E / associativity = 2)  
   <img src="/images/e_way_associative_cache.png" width=50%>   </li>
<li>Metrics<ol>
<li>Miss rate</li>
<li>Hit time</li>
<li>Miss penalty</li>
</ol>
</li>
<li>Write cache-friendly code<ol>
<li>Make the common cases go first</li>
<li>Minimize the misses in inner loops</li>
<li>Try to maximize spatial locality by reading objects sequentially with stride 1</li>
<li>Try to maximize temporal locality by using an object as often as possible once it’s read from memory</li>
</ol>
</li>
<li>Example of matrix multiplication<ul>
<li>In which order to arrange the loops? Do miss rate analysis!</li>
<li>It turns out: kij/ikj &gt; ijk/jik &gt; jki/kji</li>
<li>Use blocking: multiplying by sub-matrices</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h1><ul>
<li><p>Why linkers?</p>
<ol>
<li>Modularity</li>
<li>Efficiency (separate complilation)</li>
</ol>
</li>
<li><p>Two kind of linking</p>
<ol>
<li>Static linking</li>
<li>Dynamic linking</li>
</ol>
</li>
<li><p>What does linker do?</p>
<ol>
<li><p>Symbol resolution</p>
<ul>
<li><p>Functions, <code>global</code> vars, <code>static</code> vars</p>
</li>
<li><p>Definitions are stored in <strong>symbol table</strong>, an array of entries (name, size, location)</p>
</li>
<li><p>Three kind of symbols:</p>
<ol>
<li>Global symbols: non-static functions and non-static vars</li>
<li>External symbols: defined in other modules</li>
<li>Local symbols: static functions and static vars</li>
</ol>
<ul>
<li>Note: Do not confuse local symbols with local variables. Local variables are allocated in stack at runtime, and have nothing to do with linker. </li>
</ul>
</li>
<li><p>Symbol resolution</p>
<ul>
<li>Symbols are strong or weak:<ol>
<li>Strong: functions and initialized globals</li>
<li>Weak: uninitialized globals</li>
</ol>
</li>
<li>Multiple strong symbols are not allowed</li>
<li>Choose the strong symbol over weak symbols</li>
<li>If there are multiple weak symbols, choose arbitrary one <ul>
<li>May cause undefined behavior over different compilers</li>
<li>Fix: use <code>static</code> and explicit <code>extern</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Relocation</p>
<ul>
<li>Merge text and data segment</li>
<li>Relative location -&gt; absolute location</li>
<li>Updates symbol table<ul>
<li>Relocation entries are used to aid symbol resolving:<br><code>a: R_X86_64_32 array</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Three kinds of object files</p>
<ol>
<li>Relocatable object file (.o file)</li>
<li>Executable object file (a.out file)</li>
<li>Shared object file (.so file or .dll file)</li>
</ol>
</li>
<li><p>ELF format (Executable and Linkable Format)  </p>
<ul>
<li>All 3 object files use ELF format  <img src="/images/elf.png" width=65%>
<img src="/images/elf_2.png" width=35%>  
</li>
</ul>
</li>
<li><p>Static libraries (.a archive files)</p>
<ul>
<li>Concatenate related relocatable object files into a single file with an index (called an archive)</li>
<li>During linking, only referenced .o files are linked</li>
<li>Command line order matters!<ul>
<li>During scan, keep a list of currently unresolved references</li>
<li>If any entries in the unresolved list at end of scan, then error</li>
<li>Fix: put libraries at the end of command line</li>
</ul>
</li>
<li>Commonly used libraries:<ul>
<li><code>libc.a</code> (the C standard library)</li>
<li><code>limb.a</code> (the C math library)</li>
</ul>
</li>
<li>Disadvantages<ul>
<li>Duplication in storage</li>
<li>Bug fixes require relink</li>
<li>Fix: shared libraries</li>
</ul>
</li>
</ul>
</li>
<li><p>Shared libraries</p>
<ul>
<li>Dynamic linking can happen at:<ol>
<li>Load time<ul>
<li>Handled by the dynamic linker</li>
<li><code>libc.so</code> usually dynamically linked</li>
</ul>
</li>
<li>Run time<ul>
<li><code>dlopen()</code> interface in linux</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Library interpositioning</p>
<ul>
<li>Can happen at:<ol>
<li>Compile time</li>
<li>Link time</li>
<li>Load/run time</li>
</ol>
</li>
<li>Can be used for:<ol>
<li>Detecting memory leaks</li>
<li>Generating address traces</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="Exception-Control-Flows-ECF"><a href="#Exception-Control-Flows-ECF" class="headerlink" title="Exception Control Flows (ECF)"></a>Exception Control Flows (ECF)</h1><ul>
<li>ECFs exists in all levels:<ol>
<li>Exceptions (low level)<ul>
<li>Processor responses to external events</li>
<li>Exception tables</li>
</ul>
</li>
<li>Context switch</li>
<li>Signals</li>
<li>Nonlocal jumps</li>
</ol>
</li>
<li>Exceptions (equivalent to user-kernel transition)  <img src="/images/exceptions.png" width=50%>  
1. Asynchronous (Interrupts)
   * Indicated by INT pin
   * Control flow returns to next instruction
2. Synchronous
   1. Traps
      * Intentional (syscall, breakpoints)
      * Control flow returns to next instruction
   2. Faults
      * Unintentional but possibly recoverable
      * Control flow returns to current instruction or aborts
   3. Aborts
      * Unintentional and unrecoverable</li>
<li>Context switches</li>
</ul>
<h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><ul>
<li><p>From a programmer’s perspective, a process can be:</p>
<ol>
<li>Running: Executing or will be scheduled</li>
<li>Stopped: Suspended and will not be scheduled until further notice</li>
<li>Terminated: Stopped permanently (zombie)<ul>
<li>Process terminates when: <ol>
<li><code>SIGTERM</code> received</li>
<li>Return from <code>main()</code></li>
<li>Called <code>exit()</code></li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Creating process: <code>fork()</code></p>
<ul>
<li><code>fork()</code> called once but returns twice</li>
<li><code>exit()</code> and <code>execve()</code> called once but possibly never returns</li>
<li>Control flow can be modelled with process graphs via toposort:  <img src="/images/process_graph1.png" width=30%>
<img src="/images/process_graph2.png" width=25%>
</li>
</ul>
</li>
<li><p>Reaping child processes: <code>wait()</code></p>
<ul>
<li><p>Terminated processes become zombies, because its parent may use its exit status or OS tables</p>
</li>
<li><p><code>wait()</code> and <code>waitpid()</code> reap zombie child processes</p>
</li>
<li><p>If parent don’t reap:</p>
<ol>
<li>If parent doesn’t terminate: Never diminishes (a kind of memory leak)</li>
<li>If parent does terminate: Reaped by <code>init</code> process (pid == 1)</li>
</ol>
<ul>
<li>So only need to explicitly reap long-running processes</li>
</ul>
</li>
</ul>
</li>
<li><p>Loading and running processes: <code>execve()</code></p>
<ul>
<li><code>int execve(char *filename, char *argv[], char *envp[])</code></li>
<li>Loads and runs in the current process</li>
<li>Overwrites code, data and stack</li>
<li>Retains PID, open files (e.g. <code>stdout</code>), and signal context</li>
<li>Called once and never return (except error)</li>
</ul>
</li>
<li><p>Process groups</p>
<ul>
<li>Can be get and set by <code>getpgrp()</code> and <code>setpgid()</code></li>
<li>Kill all process in a group with <code>kill -n -&lt;pid&gt;</code> </li>
</ul>
</li>
</ul>
<h1 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h1><ul>
<li><p>Unix shell: An application that runs program on behalf of the user</p>
<ul>
<li>Shell contains a basic loop and a <code>eval()</code> function</li>
<li>Two cases in <code>eval()</code>:<ol>
<li>Shell built-in command</li>
<li>Not build-in, use <code>fork()</code> and <code>execve()</code></li>
</ol>
</li>
<li><strong>Motivation</strong>: How to reap <strong>both</strong> foreground and background jobs?<ul>
<li>Basic loop: Only reaps foreground jobs</li>
<li>Fix: Signals</li>
</ul>
</li>
</ul>
</li>
<li><p>Signals</p>
<ul>
<li><p>Akin to exceptions and interrupts</p>
</li>
<li><p>Sent from signal (sometimes at the request of another process via <code>kill</code>)</p>
</li>
<li><p>Identified by an integer</p>
</li>
<li><p>Controlled by <strong>per-process</strong> <code>pending</code> and <code>blocked</code> bit vectors</p>
<ul>
<li><code>pending</code> vector set and cleared <strong>by kernel</strong> when signals is sent or received</li>
<li><code>blocked</code> vector can be manipulated by <code>sigprocmask()</code> function</li>
<li>So, signals cannot be queued</li>
</ul>
</li>
<li><p><strong>Send</strong>: <code>pending</code> bit set</p>
</li>
<li><p><strong>Receive</strong>: process reacts to the signal, clears <code>pending</code> bit</p>
<ol>
<li>Ignore</li>
<li>Terminate</li>
<li>Catch (using user-level function called <em>signal handler</em>)</li>
</ol>
</li>
<li><p>Kernels checks for <code>pnb = pending &amp; ~blocked</code> at beginning of a time-slice</p>
<ul>
<li>If <code>pnb == 0</code>:<ul>
<li>Pass control to next instruction in the process logical flow </li>
</ul>
</li>
<li>Else<ol>
<li>Choose lease non-zero bit in <code>pnb</code> and forces the process to receive the signal</li>
<li>The receipt of the signal triggers some action by the process (clears <code>pending</code> bit)</li>
<li>Repeat for all remaining nonzero bits</li>
<li>Pass control to next instruction in the process logical flow</li>
</ol>
</li>
</ul>
</li>
<li><p>Default action can be one of:</p>
<ol>
<li>Termination</li>
<li>Stop until restarted by <code>SIGCONT</code></li>
<li>Ignore</li>
</ol>
</li>
<li><p>Override default action by installing <code>signal handlers</code>:</p>
<ul>
<li><code>handler_t *signal(int signum, handler_t *handler)</code></li>
<li><code>handler</code> can be one of:<ol>
<li><code>SIG_IGN</code>: Ignore</li>
<li><code>SIG_DFL</code>: Revert to default</li>
<li>Function pointer to a user-level signal handler</li>
</ol>
</li>
</ul>
</li>
<li><p>Signal handlers are a form of concurrency  </p>
<img src="/images/concurrent_flows.png" width=40%>
<img src="/images/concurrent_flows2.png" width=50%>  
</li>
<li><p>Signal handlers can be nested  </p>
<img src="/images/nested_signal_handlers.png" width=60%>  

<ul>
<li>So we need <strong>blocking</strong><ol>
<li>Implicit blocking: blocks pendings signals of same type</li>
<li>Explicit blocking: <code>sigprogmask()</code> with supporting functions of:<ul>
<li><code>sigemptyset()</code></li>
<li><code>sigfillset()</code></li>
<li><code>sigaddset()</code></li>
<li><code>sigdelset()</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>How to write safe handlers?</p>
<ol>
<li>Keep handlers as simple as possible</li>
<li>Call only <code>async-signal-safe</code> function in handlers<ul>
<li><code>async-signal-safe</code> functions are <em>reentrent</em> (access only local variables on stack), or cannot be interrupted by another signal handler</li>
<li><code>printf()</code>, <code>malloc()</code> and <code>exit()</code> are <strong>not</strong> safe</li>
<li><code>write()</code> is the only signal-safe output function</li>
</ul>
</li>
<li>Save and restore <code>errno</code> on entry and exit</li>
<li>Protect accesses to shared data structures by temporarily blocking <strong>all</strong> signals in <strong>both</strong> handler and <code>main()</code></li>
<li>Declare global variables to be <code>volatile</code>, to prevent from being optimized into registers</li>
<li>Declare global <strong>flags</strong> as <code>volatile sig_atomic_t</code><ul>
<li>Flag: variable only read or written (not <code>flag++</code> or <code>flag+=10</code>)</li>
<li><code>volatile sig_atomic_t</code> are ints on most systems</li>
</ul>
</li>
</ol>
</li>
<li><p>Avoid race conditions</p>
<ul>
<li>Cannot make <code>any</code> assumption regarding execution order</li>
<li>However, we can control when handlers run by blocking</li>
</ul>
</li>
<li><p>Explicitly waiting for signals: suppose handler sets global variable <code>pid</code>:</p>
<ul>
<li><p>Spin wait: <code>while(!pid) &#123;&#125;</code></p>
<ul>
<li>Wasteful</li>
</ul>
</li>
<li><p>Pause: <code>while(!pid) pause()</code></p>
<ul>
<li>Race condition</li>
</ul>
</li>
<li><p>Sleep: <code>while(!pid) sleep(1)</code></p>
<ul>
<li>Too slow</li>
</ul>
</li>
<li><p>Solution: <code>sigsuspend</code></p>
<ul>
<li><p><code>int sigsuspend(const sigset_t *mask)</code></p>
</li>
<li><p>Equivalent to <strong>atomic</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">pause()</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;prev, NULL);    </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Portable signal handling</p>
<ul>
<li>Problem: Different versions of unix have different signal handling semantics</li>
<li>Solution: Use <code>sigaction</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h1><ul>
<li>Physical Addressing: Used in microcontrollers, embedded systems, etc.</li>
<li><strong>Mentality</strong>: Main memory is a fully-associative cache for disk<ul>
<li>Load doesn’t necessarily happen with <code>execve()</code>. It only allocates virtual address space with valid bit of 0</li>
<li><strong>Loading is a result of a page fault</strong> (demand paging)</li>
</ul>
</li>
<li>Kernel memory invisible to application program. Kernel’s address space starts with 1.</li>
<li>Every memory access go through cache memory:<ul>
<li>Both memory and cache gets updated after page fault  <img src="/images/vm_and_cache.png" width=60%>  </li>
</ul>
</li>
<li>Address translation: Multi-level page tables</li>
<li>TLB: Small <strong>set-associative</strong> hardware cache in MMU</li>
<li>Works only because of locality</li>
</ul>
<h1 id="System-Level-I-O"><a href="#System-Level-I-O" class="headerlink" title="System-Level I/O"></a>System-Level I/O</h1><ul>
<li><p>Unix I/O</p>
<ol>
<li>Opening and closing files: <code>open()</code>, <code>close()</code></li>
<li>Reading and writing files: <code>read()</code>, <code>write()</code></li>
<li>Changing file position: <code>lseek()</code></li>
<li>View file metadata: <code>stat()</code><ul>
<li><code>stat()</code> are both a syscall and a linux program</li>
<li>Syscalls are in second section of man: <code>man 2 stat</code> </li>
</ul>
</li>
</ol>
<ul>
<li>Always check return codes for these syscalls</li>
</ul>
</li>
<li><p>File types: Regular, directory, socket, named pipes, symlinks, character and block devices</p>
</li>
<li><p>Short counts: (<code>nbytes &lt; sizeof(buf)</code>) are possible</p>
</li>
<li><p>Wrapper: RIO (robust I/O) package</p>
<ol>
<li>Unbuffered I/O of binary data: <code>rio_readn()</code> and <code>rio_writen()</code></li>
<li>Buffered I/O of text or binary: <code>rio_readlineb()</code> and <code>rio_readnb()</code></li>
</ol>
<ul>
<li>RIO package is better for input and output on network sockets</li>
</ul>
</li>
<li><p>Standard I/O</p>
<ol>
<li>Opening and closing: <code>fopen()</code> and <code>fclose()</code></li>
<li>Reading and writing bytes: <code>fread()</code> and <code>fwrite()</code></li>
<li>Reading and writing text lines: <code>fgets()</code> and <code>fputs()</code></li>
<li>Formatted reading and writing: <code>fscanf()</code> and <code>fprintf()</code></li>
</ol>
<ul>
<li>C program begin with 3 open files:<ol>
<li><code>stdin</code> (descriptor 0) </li>
<li><code>stdout</code> (descriptor 1)</li>
<li><code>stderr</code> (descriptor 2)</li>
</ol>
</li>
</ul>
</li>
<li><p>Trace syscalls with the Linux <code>strace</code> program</p>
</li>
<li><p>Choosing I/O functions</p>
<ul>
<li>General: Use highest-level functions</li>
<li>When to use Unix I/O: Signal handlers because unix I/O functions are <code>async-signal-safe</code></li>
<li>When to use standard I/O: Disks, terminals</li>
<li>When to use RIO: Network sockets</li>
</ul>
</li>
<li><p>How kernel represents open files  </p>
<img src="/images/open_files1.png" width=60%>

<ul>
<li>Open file table: An instance of opening file<ul>
<li>If a process opens a file twice, there are two open file tables pointing to the same v-node table</li>
</ul>
</li>
<li>V-node table: File metadata (regardless of whether file is open)</li>
<li>After <code>fork()</code>, <code>refcnt</code> is incremented:  <img src="/images/open_files2.png" width=60%>  
* Two processes share a same instance of opened file (including file position)</li>
<li><code>dup2(int oldfd, int newfd)</code>: Used for I/O redirection<ul>
<li>After calling <code>dup2(4, 1)</code>:  <img src="/images/open_files3.png" width=60%>  
</li>
</ul>
</li>
</ul>
</li>
<li><p>Recommended references:</p>
<ul>
<li>W. Richard Stevens &amp; Stephen A. Rago, <em>Advanced Programming in the Unix Environment</em>, 2 nd Edition, Addison Wesley, 2005</li>
</ul>
</li>
</ul>
<h1 id="Virtual-Memory-Systems"><a href="#Virtual-Memory-Systems" class="headerlink" title="Virtual Memory: Systems"></a>Virtual Memory: Systems</h1><ul>
<li>End-to-end Core i7 Address Translation  <img src="/images/address_translation.png" width=80%>  </li>
<li>L1 d-cache <code>index</code> and <code>offset</code> have 12 bits is NOT a coincidence: Speed up address translation  <img src="/images/cache_speedup.png" width=50%>  </li>
<li>Linux organizes VM as collections of areas:  <ul>
<li>Fault handling: Traverse the <code>vm_area_struct</code>s to check if page is allocated<img src="/images/areas.png" width=80%>  </li>
</ul>
</li>
<li>Private Copy-on-write (COW)</li>
<li>Memory Mapping: <code>void *mmap(void *start, int len, int prot, int flags, int fd, int offset)</code><ul>
<li><code>start</code>: A hint address</li>
<li><code>prot</code>: <code>PROT_READ</code>, <code>PROT_WRITE</code>, <code>PROT_EXEC</code> </li>
<li><code>flags</code>: <code>MAP_ANON</code>, <code>MAP_PRIVATE</code>, <code>MAP_SHARED</code></li>
<li>Returns a pointer to the start of mapped area (may not be start)</li>
</ul>
</li>
</ul>
<h1 id="Dynamic-Memory-Allocation"><a href="#Dynamic-Memory-Allocation" class="headerlink" title="Dynamic Memory Allocation"></a>Dynamic Memory Allocation</h1><ul>
<li>Allocators: Maintain the heap as a collection of variable sized blocks, which are either <em>allocated</em> or <em>free</em><ul>
<li>Explicit allocator: Application allocates and frees</li>
<li>Implicit allocator: Application allocates but not frees</li>
</ul>
</li>
<li>The <code>malloc</code> package<ul>
<li><code>void *malloc(size_t size)</code></li>
<li><code>void free(void *p)</code></li>
<li><code>calloc</code>: Initializes allocated blocks to 0</li>
<li><code>realloc</code>: Changes size of previously allocated block</li>
<li><code>sbrk</code>: Used internally by allocators to grow and shrink the heap</li>
</ul>
</li>
<li>Constraints:<ul>
<li>Applications have few constraints</li>
<li>Allocators have many constraints:<ol>
<li>Can’t assume allocation patterns</li>
<li>Must respond immediately to <code>malloc</code> (can’t defer allocation)</li>
<li>Can’t relocate allocated memory</li>
</ol>
</li>
</ul>
</li>
<li>Performance goal (2 conflicting goals)<ul>
<li>Throughput: Number of completed requests per unit time</li>
<li>Peak memory utilization: How to efficiently use memory</li>
</ul>
</li>
<li>Fragmentation<ul>
<li>Internal fragmentation: <ul>
<li>Payload smaller than block size</li>
<li>Easy to measure</li>
</ul>
</li>
<li>External fragmentation: <ul>
<li>Enough aggregate heap memory, but no single free block large enough</li>
<li>Difficult to measure</li>
</ul>
</li>
</ul>
</li>
<li>Keeping track of free blocks  <img src="/images/keeping_track_of_free_lists.png" width=50%>  </li>
<li>How to find a free block<ol>
<li>First fit</li>
<li>Next fit</li>
<li>Best fit</li>
</ol>
</li>
<li>Know how much to free: Header<ul>
<li>Encodes block size (including the header and any padding) </li>
<li>Alignment means lower-bits of size are 0, used to encode allocated bit  <img src="/images/implicit_free_list.png" width=50%>  </li>
</ul>
</li>
<li>Implicit list<ul>
<li>Allocating a free block: May need to split the block</li>
<li>Freeing a block: Have to coalesce free blocks (4 cases):  <img src="/images/coalescing.png" width=50%>  </li>
<li>Singly-linked list cannot free previous block in constant time<ul>
<li>Fix: Doubly-linked list (head and footer)</li>
<li>Optimization: <ul>
<li>Allocated blocks doesn’t need coalescing</li>
<li>We have extra bits to encode whether previous block is allocated  </li>
<li>So, allocated blocks doesn’t need footer</li>
</ul>
</li>
</ul>
</li>
<li>Implicit lists are not commonly used because of linear time. However, the concepts of splitting and coalescing are general to <strong>all</strong> allcators</li>
</ul>
</li>
<li>Explicit free list  <img src="/images/explicit_free_list.png" width=50%>  
* Maintain list of free blocks using payload area
* Blocks can be in any order (depending on insertion policy)
  * Unordered: LIFO, FIFO
  * Address-ordered
* Much faster than implicit lists when memory is full</li>
<li>Segregated list  <img src="/images/segregated_list.png" width=40%>  </li>
<li>Garbage collection  <img src="/images/memory_graph.png" width=50%>  
* Mark and sweep collecting
  * Allocate using `malloc` until run out of space
  * Use extra mark bit for each block
  * Root nodes: Pointers in stack/data section
  * Does not distinguish between pointers/non-pointers, thus "safe"
  * _Mark_: Start at root nodes and do DFS
  * _Sweep_: Start at beginning of VM, and free unmarked blocks
  * How to find beginning of block? -- Use a balanced tree

</li>
</ul>
<h1 id="Network-Programming"><a href="#Network-Programming" class="headerlink" title="Network Programming"></a>Network Programming</h1><ul>
<li>Client-Server Architecture</li>
<li>Network Architecture<ul>
<li>Routers set borders of LANs</li>
<li>Conceptual view of LANs:  <img src="/images/LAN.png" width=20%>  </li>
</ul>
</li>
<li>Socket<ul>
<li>To the kernel: An endpoint of communication</li>
<li>To application: A file descriptor to write/read</li>
<li>Generic socket address:  <img src="/images/socket_generic.png" width=80%>  </li>
<li>IPv4 specific socket address:  <img src="/images/socket_ipv4.png" width=80%>   </li>
</ul>
</li>
<li>Host and Service Conversion: <code>getaddrinfo</code><ul>
<li>Convert string representations of hostnames, host addresses, ports and service names to socket address structures  <img src="/images/getaddrinfo.png" width=80%>   
<img src="/images/addrinfo.png" width=80%>   </li>
<li><code>getnameinfo</code> is the inverse of <code>getaddrinfo</code></li>
</ul>
</li>
<li>Client/Server interface  <img src="/images/client_server.png" width=80%>   </li>
<li><code>telnet</code>: Testing servers<ul>
<li>Creates TCP connection with a server (starts a session)</li>
<li>Since the encoding of HTTP is ascii, we can hard-code http requests</li>
</ul>
</li>
<li>HTTP<ul>
<li>Content: A sequence of bytes in MIME (Multipurpose Internet Mail Extension) type</li>
<li>The contents can be either <em>static</em> or <em>dynamic</em></li>
</ul>
</li>
<li>Dynamic content: <ul>
<li>Produced by server-side program</li>
<li>If URI containts <code>cgi-bin</code> then serve dynamic content</li>
<li>Use <code>fork()</code> and <code>exec()</code> to execute new program</li>
<li>Use env-var <code>QUERY_STRING</code> to pass parameters</li>
</ul>
</li>
</ul>
<h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><ul>
<li>Iterative servers have serious flaws. <ul>
<li>Easily get blocked by single misbehaving client<ul>
<li>Note: Blocking does not happen upon client calling <code>connect()</code> or <code>write()</code>, but upon <code>read()</code>. This is because server’s kernel provides buffering</li>
</ul>
</li>
<li>So we need concurrent servers</li>
</ul>
</li>
</ul>
<ol>
<li>Process-based servers<ul>
<li>Parent <strong>must</strong> close connected socket (parent doesn’t get reaped)</li>
<li>Child <strong>should</strong> close listening socket (child gets reaped)</li>
<li>Reap child with <code>SIGCHLD</code> handler</li>
</ul>
</li>
<li>Event-based servers<ul>
<li>Manage multiple connections in user space </li>
<li>Determine events using <code>select()</code> or <code>epoll()</code></li>
<li>Design of choice for high-performance web servers</li>
<li>However, hard to provide find-grained concurrency</li>
<li>Cannot take advantage of multi-core</li>
</ul>
</li>
<li>Thread-based servers<ul>
<li>Can run threads in <code>detached</code> mode. It will run independently, and get reaped automatically</li>
<li>Possible race conditions when passing parameters to new thread in <code>pthread_create()</code></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yupangzi18.github.io/cmu-15-213-intro-to-computer-systems/index.html" data-id="ckiitlfnb0001aku40g7ag62k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hello-world/index.html" class="article-date">
  <time datetime="2020-11-26T02:38:44.286Z" itemprop="datePublished">2020-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hello-world/index.html">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yupangzi18.github.io/hello-world/index.html" data-id="ckiitlfn50000aku468r505as" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/cmu-15-213-intro-to-computer-systems/index.html">CMU-15-213-Intro-to-Computer-Systems</a>
          </li>
        
          <li>
            <a href="/hello-world/index.html">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Yu Luo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>